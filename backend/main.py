from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse
from backend.models import (
    UserMessage, HealthLog, 
    ChildProfile, ChildProfileCreate, ChildProfileUpdate,
    ScenarioRequest, ScenarioInfo
)
from backend.services.brain_service import analyze_intent, generate_leo_response
from backend.child_profiles import (
    create_child, get_child, list_children, update_child, delete_child,
    get_child_history, clear_child_history, update_child_stats, append_event_to_history
)
from backend.scenarios import list_scenarios, get_scenario, SCENARIOS
from backend.data_simulator import MedicalDataSimulator
import asyncio
import json
import os
from datetime import datetime
from typing import List, Optional
from pydantic import BaseModel
from pathlib import Path

app = FastAPI(title="Leo Health API", version="2.0")

# Allow React Frontend (localhost:3000)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Lock this down for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- GAMIFICATION STATE (Simple In-Memory for Hackathon) ---
user_stats = {
    "xp": 120,
    "level": 3,
    "streak": 5,
    "status": "Healthy"
}

# --- HEALTH DATA STORAGE ---
health_events: List[dict] = []
health_logs: List[dict] = []

# Data directory paths
DATA_DIR = Path(__file__).parent.parent / "data"
HISTORY_DIR = DATA_DIR / "history"

# Path to events.jsonl (generated by data_simulator.py) - legacy fallback
EVENTS_FILE = os.path.join(os.path.dirname(os.path.dirname(__file__)), "events.jsonl")

# Active simulators (for background simulation tasks)
active_simulators: dict = {}


@app.on_event("startup")
def _seed_demo_child_if_empty():
    """
    Ensure a freshly-cloned repo has at least one child profile,
    so the frontend dashboard isn't empty on first run.
    """
    try:
        children = list_children()
        if children:
            return
        create_child(ChildProfileCreate(
            name="Maya",
            age=7,
            condition="none",
            parent_name="Demo Parent",
        ))
        print("âœ… Seeded demo child profile (Maya)")
    except Exception as e:
        # Never fail startup just because demo data couldn't be created
        print(f"âš ï¸ Could not seed demo child: {e}")

def load_latest_events(limit: int = 50) -> List[dict]:
    """Load the latest events from events.jsonl"""
    events = []
    if os.path.exists(EVENTS_FILE):
        try:
            with open(EVENTS_FILE, 'r') as f:
                lines = f.readlines()
                # Get last N lines
                for line in lines[-limit:]:
                    try:
                        events.append(json.loads(line.strip()))
                    except json.JSONDecodeError:
                        continue
        except Exception as e:
            print(f"Error reading events file: {e}")
    return events

def get_current_health_state() -> dict:
    """Get the current health state from the latest event"""
    events = load_latest_events(1)
    if events:
        event = events[0]
        return {
            "glucose": extract_metric(event, "glucose", 5.5),
            "heart_rate": extract_metric(event, "heart_rate", 85),
            "mood": extract_metric(event, "mood", 0.7),
            "activity": extract_metric(event, "activity", 0.5),
            "spo2": extract_metric(event, "oxygen", 98),
            "asthma_risk": extract_metric(event, "asthma", 0.2),
            "health_score": event.get("health_score", 75),
            "safety_status": event.get("safety_status", "SAFE"),
            "last_event": event
        }
    return {
        "glucose": 5.5,
        "heart_rate": 85,
        "mood": 0.7,
        "activity": 0.5,
        "spo2": 98,
        "asthma_risk": 0.2,
        "health_score": 75,
        "safety_status": "SAFE",
        "last_event": None
    }

def extract_metric(event: dict, keyword: str, default: float) -> float:
    """Extract a metric value from an event based on event type"""
    event_type = event.get("event_type", "")
    if keyword in event_type.lower():
        return event.get("value", default)
    return default

@app.get("/")
def health_check():
    return {"status": "Leo is awake!", "stats": user_stats}

@app.get("/api/health/current")
def get_current_health():
    """Get current health metrics from simulator"""
    state = get_current_health_state()
    return {
        "metrics": {
            "glucose": {
                "value": state["glucose"],
                "unit": "mmol/L",
                "status": "normal" if 4.0 <= state["glucose"] <= 7.0 else "warning" if state["glucose"] < 4.0 else "elevated"
            },
            "heart_rate": {
                "value": state["heart_rate"],
                "unit": "bpm",
                "status": "normal" if 70 <= state["heart_rate"] <= 110 else "warning"
            },
            "mood": {
                "value": state["mood"],
                "unit": "score",
                "status": "good" if state["mood"] > 0.6 else "low" if state["mood"] < 0.4 else "neutral"
            },
            "activity": {
                "value": state["activity"],
                "unit": "score",
                "status": "active" if state["activity"] > 0.6 else "sedentary" if state["activity"] < 0.3 else "moderate"
            },
            "spo2": {
                "value": state["spo2"],
                "unit": "%",
                "status": "normal" if state["spo2"] >= 95 else "low"
            },
            "asthma_risk": {
                "value": state["asthma_risk"],
                "unit": "score",
                "status": "low" if state["asthma_risk"] < 0.4 else "moderate" if state["asthma_risk"] < 0.7 else "high"
            }
        },
        "health_score": state["health_score"],
        "safety_status": state["safety_status"],
        "timestamp": datetime.now().isoformat()
    }

@app.get("/api/health/events")
def get_health_events(limit: int = 20):
    """Get recent health events from simulator"""
    events = load_latest_events(limit)
    
    # Transform events for frontend
    formatted_events = []
    for event in events:
        formatted_events.append({
            "id": event.get("timestamp", ""),
            "type": event.get("event_type", "unknown"),
            "value": event.get("value", 0),
            "unit": event.get("unit", ""),
            "urgency": event.get("urgency", "low"),
            "safety_status": event.get("safety_status", "SAFE"),
            "health_score": event.get("health_score", 75),
            "anomaly_score": event.get("anomaly_score", 0),
            "trend": event.get("trend", "stable"),
            "reasoning": event.get("llm_reasoning", ""),
            "timestamp": event.get("timestamp", ""),
            "correlations": event.get("correlation_tags", []),
            "metadata": event.get("metadata", {})
        })
    
    return {
        "events": formatted_events,
        "total": len(formatted_events),
        "timestamp": datetime.now().isoformat()
    }

@app.get("/api/health/statistics")
def get_health_statistics():
    """Get health statistics summary"""
    events = load_latest_events(100)
    
    if not events:
        return {
            "total_events": 0,
            "danger_count": 0,
            "monitor_count": 0,
            "safe_count": 0,
            "avg_health_score": 75,
            "avg_glucose": 5.5,
            "avg_heart_rate": 85,
            "anomalies_detected": 0
        }
    
    # Calculate statistics
    danger_count = sum(1 for e in events if e.get("safety_status") == "DANGER")
    monitor_count = sum(1 for e in events if e.get("safety_status") == "MONITOR")
    safe_count = sum(1 for e in events if e.get("safety_status") == "SAFE")
    
    health_scores = [e.get("health_score", 75) for e in events if e.get("health_score")]
    avg_health = sum(health_scores) / len(health_scores) if health_scores else 75
    
    glucose_values = [e.get("value", 5.5) for e in events if "glucose" in e.get("event_type", "")]
    avg_glucose = sum(glucose_values) / len(glucose_values) if glucose_values else 5.5
    
    hr_values = [e.get("value", 85) for e in events if "heart" in e.get("event_type", "")]
    avg_hr = sum(hr_values) / len(hr_values) if hr_values else 85
    
    anomalies = sum(1 for e in events if (e.get("anomaly_score") or 0) > 0.7)
    
    return {
        "total_events": len(events),
        "danger_count": danger_count,
        "monitor_count": monitor_count,
        "safe_count": safe_count,
        "avg_health_score": round(avg_health, 1),
        "avg_glucose": round(avg_glucose, 2),
        "avg_heart_rate": round(avg_hr, 0),
        "anomalies_detected": anomalies,
        "timestamp": datetime.now().isoformat()
    }

@app.get("/api/health/alerts")
def get_health_alerts():
    """Get current health alerts that need attention"""
    events = load_latest_events(50)
    
    alerts = []
    for event in events:
        if event.get("safety_status") in ["DANGER", "MONITOR"]:
            alerts.append({
                "id": event.get("timestamp", ""),
                "type": event.get("event_type", "unknown"),
                "value": event.get("value", 0),
                "unit": event.get("unit", ""),
                "severity": "critical" if event.get("safety_status") == "DANGER" else "warning",
                "message": event.get("llm_reasoning", "Health event requires attention"),
                "timestamp": event.get("timestamp", ""),
                "health_score": event.get("health_score", 0),
                "urgency": event.get("urgency", "medium")
            })
    
    # Sort by timestamp (most recent first)
    alerts.sort(key=lambda x: x["timestamp"], reverse=True)
    
    return {
        "alerts": alerts[:10],  # Return top 10 alerts
        "total": len(alerts),
        "has_critical": any(a["severity"] == "critical" for a in alerts),
        "timestamp": datetime.now().isoformat()
    }

@app.post("/api/chat/stream")
async def chat_stream(user_msg: UserMessage):
    """
    The Main Interaction Loop:
    1. Analyze Intent (DeepSeek)
    2. Stream Response (Gemma)
    """
    print(f"ðŸ¦ User ({user_msg.age}y): {user_msg.message}")
    
    # 1. Logic / Safety Check
    intent = await analyze_intent(user_msg.message, user_msg.age)
    print(f"ðŸ§  Brain Analysis: {intent}")
    
    # 2. Empathy Stream
    return StreamingResponse(
        generate_leo_response(user_msg, intent), 
        media_type="text/event-stream"
    )

@app.post("/api/log/health")
def log_health(log: HealthLog):
    global user_stats

    # Normalize / compute XP gained
    xp_gained = int((log.health_score or 50) / 10)  # 100 health ~= 10 XP
    xp_gained = max(1, xp_gained)

    # 1) Update global gamification state (legacy / demo)
    user_stats["xp"] += xp_gained

    # 2) Update Status Text based on safety status
    if log.safety_status == "DANGER":
        user_stats["status"] = "Needs Help! ðŸš¨"
    elif log.safety_status == "MONITOR":
        user_stats["status"] = "Check Engine âš ï¸"
    else:
        user_stats["status"] = "Super Strong ðŸ¦"

    # 3) Dynamic Avatar State (For the UI to react)
    avatar_mood = "happy"
    if log.event_type == "glucose_drop" or log.safety_status == "DANGER":
        avatar_mood = "worried"

    # Check for global level up
    if user_stats["xp"] >= user_stats["level"] * 100:
        user_stats["level"] += 1
        user_stats["xp"] = user_stats["xp"] - ((user_stats["level"] - 1) * 100)

    # Persist the incoming event so the frontend can render live data.
    event_dict = log.model_dump()

    # Store in global log list (used by /api/logs/health)
    health_logs.append(event_dict)

    # Route to child history if possible (frontend primarily uses per-child endpoints)
    child_id = event_dict.get("child_id")
    if not child_id:
        # If the stream didn't specify a child, default to the first registered child.
        children = list_children()
        if children:
            child_id = children[0].id
            event_dict["child_id"] = child_id

    if child_id and get_child(child_id):
        append_event_to_history(child_id, event_dict)
        update_child_stats(child_id, xp_gain=xp_gained)
    else:
        # Legacy fallback: write to events.jsonl so global /api/health/* endpoints can update.
        try:
            Path(EVENTS_FILE).parent.mkdir(parents=True, exist_ok=True)
            with open(EVENTS_FILE, "a", encoding="utf-8") as f:
                f.write(json.dumps(event_dict) + "\n")
        except Exception as e:
            print(f"Error writing to events file: {e}")

    return {
        "event": "LOGGED",
        "xp_gained": xp_gained,
        "avatar_mood": avatar_mood,
        "child_id": child_id,
    }

@app.get("/api/logs/health")
def get_health_logs(limit: int = 50):
    """Get stored health logs"""
    return {
        "logs": health_logs[-limit:],
        "total": len(health_logs)
    }


# ============================================================================
# CHILD PROFILE APIs
# ============================================================================

@app.get("/api/children", response_model=List[ChildProfile])
def api_list_children():
    """List all registered children"""
    return list_children()


@app.get("/api/children/{child_id}")
def api_get_child(child_id: str):
    """Get a specific child's profile"""
    child = get_child(child_id)
    if not child:
        raise HTTPException(status_code=404, detail=f"Child {child_id} not found")
    return child


@app.post("/api/children", response_model=ChildProfile)
def api_create_child(profile: ChildProfileCreate):
    """Create a new child profile"""
    return create_child(profile)


@app.put("/api/children/{child_id}", response_model=ChildProfile)
def api_update_child(child_id: str, updates: ChildProfileUpdate):
    """Update a child's profile"""
    child = update_child(child_id, updates)
    if not child:
        raise HTTPException(status_code=404, detail=f"Child {child_id} not found")
    return child


@app.delete("/api/children/{child_id}")
def api_delete_child(child_id: str):
    """Delete a child's profile and history"""
    success = delete_child(child_id)
    if not success:
        raise HTTPException(status_code=404, detail=f"Child {child_id} not found")
    return {"message": f"Child {child_id} deleted successfully"}


# ============================================================================
# PARENT DASHBOARD APIs (Per-Child Data)
# ============================================================================

@app.get("/api/children/{child_id}/history")
def api_get_child_history(child_id: str, limit: int = 50):
    """Get a child's health event history"""
    child = get_child(child_id)
    if not child:
        raise HTTPException(status_code=404, detail=f"Child {child_id} not found")
    
    events = get_child_history(child_id, limit)
    
    # Format events for frontend
    formatted_events = []
    for event in events:
        formatted_events.append({
            "id": event.get("timestamp", ""),
            "type": event.get("event_type", "unknown"),
            "value": event.get("value", 0),
            "unit": event.get("unit", ""),
            "urgency": event.get("urgency", "low"),
            "safety_status": event.get("safety_status", "SAFE"),
            "health_score": event.get("health_score", 75),
            "anomaly_score": event.get("anomaly_score", 0),
            "trend": event.get("trend", "stable"),
            "reasoning": event.get("llm_reasoning", ""),
            "timestamp": event.get("timestamp", ""),
            "correlations": event.get("correlation_tags", []),
            "metadata": event.get("metadata", {})
        })
    
    return {
        "child_id": child_id,
        "child_name": child.name,
        "events": formatted_events,
        "total": len(formatted_events),
        "timestamp": datetime.now().isoformat()
    }


@app.get("/api/children/{child_id}/statistics")
def api_get_child_statistics(child_id: str):
    """Get health statistics for a specific child"""
    child = get_child(child_id)
    if not child:
        raise HTTPException(status_code=404, detail=f"Child {child_id} not found")
    
    events = get_child_history(child_id, 100)
    
    if not events:
        return {
            "child_id": child_id,
            "child_name": child.name,
            "total_events": 0,
            "danger_count": 0,
            "monitor_count": 0,
            "safe_count": 0,
            "avg_health_score": 75,
            "avg_glucose": child.baseline_glucose,
            "avg_heart_rate": child.baseline_heart_rate,
            "anomalies_detected": 0,
            "xp": child.xp,
            "level": child.level,
            "streak": child.streak,
            "timestamp": datetime.now().isoformat()
        }
    
    # Calculate statistics
    danger_count = sum(1 for e in events if e.get("safety_status") == "DANGER")
    monitor_count = sum(1 for e in events if e.get("safety_status") == "MONITOR")
    safe_count = sum(1 for e in events if e.get("safety_status") == "SAFE")
    
    health_scores = [e.get("health_score", 75) for e in events if e.get("health_score")]
    avg_health = sum(health_scores) / len(health_scores) if health_scores else 75
    
    glucose_values = [e.get("value", child.baseline_glucose) for e in events if "glucose" in e.get("event_type", "")]
    avg_glucose = sum(glucose_values) / len(glucose_values) if glucose_values else child.baseline_glucose
    
    hr_values = [e.get("value", child.baseline_heart_rate) for e in events if "heart" in e.get("event_type", "")]
    avg_hr = sum(hr_values) / len(hr_values) if hr_values else child.baseline_heart_rate
    
    anomalies = sum(1 for e in events if (e.get("anomaly_score") or 0) > 0.7)
    
    return {
        "child_id": child_id,
        "child_name": child.name,
        "condition": child.condition,
        "total_events": len(events),
        "danger_count": danger_count,
        "monitor_count": monitor_count,
        "safe_count": safe_count,
        "avg_health_score": round(avg_health, 1),
        "avg_glucose": round(avg_glucose, 2),
        "avg_heart_rate": round(avg_hr, 0),
        "anomalies_detected": anomalies,
        "xp": child.xp,
        "level": child.level,
        "streak": child.streak,
        "timestamp": datetime.now().isoformat()
    }


@app.get("/api/children/{child_id}/alerts")
def api_get_child_alerts(child_id: str):
    """Get health alerts for a specific child"""
    child = get_child(child_id)
    if not child:
        raise HTTPException(status_code=404, detail=f"Child {child_id} not found")
    
    events = get_child_history(child_id, 50)
    
    alerts = []
    for event in events:
        if event.get("safety_status") in ["DANGER", "MONITOR"]:
            alerts.append({
                "id": event.get("timestamp", ""),
                "type": event.get("event_type", "unknown"),
                "value": event.get("value", 0),
                "unit": event.get("unit", ""),
                "severity": "critical" if event.get("safety_status") == "DANGER" else "warning",
                "message": event.get("llm_reasoning", "Health event requires attention"),
                "timestamp": event.get("timestamp", ""),
                "health_score": event.get("health_score", 0),
                "urgency": event.get("urgency", "medium")
            })
    
    # Sort by timestamp (most recent first)
    alerts.sort(key=lambda x: x["timestamp"], reverse=True)
    
    return {
        "child_id": child_id,
        "child_name": child.name,
        "alerts": alerts[:10],
        "total": len(alerts),
        "has_critical": any(a["severity"] == "critical" for a in alerts),
        "timestamp": datetime.now().isoformat()
    }


@app.get("/api/children/{child_id}/current")
def api_get_child_current_health(child_id: str):
    """Get current health status for a specific child"""
    child = get_child(child_id)
    if not child:
        raise HTTPException(status_code=404, detail=f"Child {child_id} not found")
    
    # Get most recent event
    events = get_child_history(child_id, 1)
    
    if events:
        event = events[-1]  # Most recent
        return {
            "child_id": child_id,
            "child_name": child.name,
            "metrics": {
                "glucose": {
                    "value": event.get("value", child.baseline_glucose) if "glucose" in event.get("event_type", "") else child.baseline_glucose,
                    "unit": "mmol/L",
                    "status": "normal"
                },
                "heart_rate": {
                    "value": event.get("value", child.baseline_heart_rate) if "heart" in event.get("event_type", "") else child.baseline_heart_rate,
                    "unit": "bpm",
                    "status": "normal"
                }
            },
            "health_score": event.get("health_score", 75),
            "safety_status": event.get("safety_status", "SAFE"),
            "last_event": event,
            "xp": child.xp,
            "level": child.level,
            "timestamp": datetime.now().isoformat()
        }
    
    # No events yet - return baseline
    return {
        "child_id": child_id,
        "child_name": child.name,
        "metrics": {
            "glucose": {"value": child.baseline_glucose, "unit": "mmol/L", "status": "normal"},
            "heart_rate": {"value": child.baseline_heart_rate, "unit": "bpm", "status": "normal"}
        },
        "health_score": 75,
        "safety_status": "SAFE",
        "last_event": None,
        "xp": child.xp,
        "level": child.level,
        "timestamp": datetime.now().isoformat()
    }


@app.delete("/api/children/{child_id}/history")
def api_clear_child_history(child_id: str):
    """Clear a child's event history"""
    child = get_child(child_id)
    if not child:
        raise HTTPException(status_code=404, detail=f"Child {child_id} not found")
    
    clear_child_history(child_id)
    return {"message": f"History cleared for {child.name}"}


# ============================================================================
# SIMULATION CONTROL APIs
# ============================================================================

@app.get("/api/scenarios")
def api_list_scenarios(condition: str = None):
    """List all available simulation scenarios"""
    scenarios = list_scenarios(condition)
    return {
        "scenarios": scenarios,
        "total": len(scenarios),
        "categories": {
            "episode": [s for s in scenarios if s["category"] == "episode"],
            "full_day": [s for s in scenarios if s["category"] == "full_day"]
        }
    }


@app.get("/api/scenarios/{scenario_id}")
def api_get_scenario(scenario_id: str):
    """Get details about a specific scenario"""
    try:
        scenario = get_scenario(scenario_id)
        return {
            "id": scenario.id,
            "name": scenario.name,
            "description": scenario.description,
            "category": scenario.category.value,
            "duration_minutes": scenario.duration_minutes,
            "conditions": scenario.applicable_conditions
        }
    except ValueError:
        raise HTTPException(status_code=404, detail=f"Scenario {scenario_id} not found")


@app.post("/api/simulate/{child_id}/scenario")
async def api_run_scenario(child_id: str, request: ScenarioRequest):
    """Run a specific scenario for a child"""
    child = get_child(child_id)
    if not child:
        raise HTTPException(status_code=404, detail=f"Child {child_id} not found")
    
    # Validate scenario exists
    try:
        scenario = get_scenario(request.scenario)
    except ValueError:
        raise HTTPException(status_code=404, detail=f"Scenario {request.scenario} not found")
    
    # Check if scenario applies to child's condition
    if child.condition not in scenario.applicable_conditions and "both" not in scenario.applicable_conditions:
        raise HTTPException(
            status_code=400, 
            detail=f"Scenario {request.scenario} is not applicable for condition {child.condition}"
        )
    
    # Create simulator for this child
    async with MedicalDataSimulator(child_id=child_id) as simulator:
        events = await simulator.run_scenario(
            request.scenario,
            event_interval_seconds=request.event_interval_seconds,
            save_to_history=True
        )
    
    # Update child's XP based on events
    xp_gain = sum(5 for e in events if e.get("safety_status") == "SAFE")
    if xp_gain > 0:
        update_child_stats(child_id, xp_gain=xp_gain)
    
    return {
        "child_id": child_id,
        "scenario": request.scenario,
        "events_generated": len(events),
        "events": events,
        "xp_gained": xp_gain,
        "timestamp": datetime.now().isoformat()
    }


@app.post("/api/simulate/{child_id}/random")
async def api_run_random_simulation(child_id: str, num_events: int = 5, interval_seconds: int = 2):
    """Generate random health events for a child"""
    child = get_child(child_id)
    if not child:
        raise HTTPException(status_code=404, detail=f"Child {child_id} not found")
    
    events = []
    async with MedicalDataSimulator(child_id=child_id) as simulator:
        for _ in range(num_events):
            event = await simulator.generate_and_analyze_event()
            simulator._append_to_history(event)
            events.append(event)
            await asyncio.sleep(interval_seconds)
    
    # Update child's XP
    xp_gain = sum(5 for e in events if e.get("safety_status") == "SAFE")
    if xp_gain > 0:
        update_child_stats(child_id, xp_gain=xp_gain)
    
    return {
        "child_id": child_id,
        "mode": "random",
        "events_generated": len(events),
        "events": events,
        "xp_gained": xp_gain,
        "timestamp": datetime.now().isoformat()
    }


@app.post("/api/simulate/{child_id}/quick")
async def api_quick_scenario(child_id: str, scenario_type: str = "healthy_reading"):
    """
    Quick scenario runner with minimal delay (good for demos).
    Runs a scenario with 0 delay between events.
    """
    child = get_child(child_id)
    if not child:
        raise HTTPException(status_code=404, detail=f"Child {child_id} not found")
    
    try:
        scenario = get_scenario(scenario_type)
    except ValueError:
        raise HTTPException(status_code=404, detail=f"Scenario {scenario_type} not found")
    
    async with MedicalDataSimulator(child_id=child_id) as simulator:
        events = await simulator.run_scenario(
            scenario_type,
            event_interval_seconds=0,  # No delay
            save_to_history=True
        )
    
    return {
        "child_id": child_id,
        "scenario": scenario_type,
        "events": events,
        "count": len(events)
    }


# ============================================================================
# MEDICATION TRACKING APIs
# ============================================================================

class MedicationLog(BaseModel):
    medication_type: str  # insulin, inhaler, snack
    notes: Optional[str] = None


@app.post("/api/children/{child_id}/medications/log")
def api_log_medication(child_id: str, log: MedicationLog):
    """Log a medication administration for a child"""
    child = get_child(child_id)
    if not child:
        raise HTTPException(status_code=404, detail=f"Child {child_id} not found")
    
    # Create a medication event
    event = {
        "timestamp": datetime.now().isoformat(),
        "event_type": f"medication_{log.medication_type}",
        "value": 1,
        "unit": "dose",
        "urgency": "low",
        "safety_status": "SAFE",
        "health_score": 100,
        "trend": "stable",
        "llm_reasoning": f"{log.medication_type.title()} administered successfully",
        "metadata": {
            "medication_type": log.medication_type,
            "notes": log.notes
        }
    }
    
    append_event_to_history(child_id, event)
    
    # Award XP for taking medication
    update_child_stats(child_id, xp_gain=10)
    
    return {
        "message": f"Logged {log.medication_type} for {child.name}",
        "event": event,
        "xp_gained": 10
    }


@app.get("/api/children/{child_id}/medications")
def api_get_medication_history(child_id: str, limit: int = 20):
    """Get medication history for a child"""
    child = get_child(child_id)
    if not child:
        raise HTTPException(status_code=404, detail=f"Child {child_id} not found")
    
    events = get_child_history(child_id, 100)
    
    # Filter for medication events
    medication_events = [
        e for e in events 
        if e.get("event_type", "").startswith("medication_")
    ]
    
    return {
        "child_id": child_id,
        "child_name": child.name,
        "medications": medication_events[-limit:],
        "total": len(medication_events),
        "timestamp": datetime.now().isoformat()
    }


@app.post("/api/children/{child_id}/medications/reminder")
def api_create_medication_reminder(child_id: str, medication_type: str):
    """Create a medication reminder event (for demo purposes)"""
    child = get_child(child_id)
    if not child:
        raise HTTPException(status_code=404, detail=f"Child {child_id} not found")
    
    # Create a medication due event
    event = {
        "timestamp": datetime.now().isoformat(),
        "event_type": "medication_due",
        "value": 0,
        "unit": "reminder",
        "urgency": "medium",
        "safety_status": "MONITOR",
        "health_score": 80,
        "trend": "stable",
        "llm_reasoning": f"Time for {medication_type}! Remember to take your medicine.",
        "metadata": {
            "medication_type": medication_type,
            "due": True
        }
    }
    
    append_event_to_history(child_id, event)
    
    return {
        "message": f"Medication reminder created for {child.name}",
        "event": event
    }


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
