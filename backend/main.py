from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse
from backend.models import UserMessage, HealthLog
from backend.services.brain_service import analyze_intent, generate_leo_response
import asyncio
import json
import os
from datetime import datetime
from typing import List, Optional
from pydantic import BaseModel

app = FastAPI(title="Leo Health API", version="2.0")

# Allow React Frontend (localhost:3000)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Lock this down for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- GAMIFICATION STATE (Simple In-Memory for Hackathon) ---
user_stats = {
    "xp": 120,
    "level": 3,
    "streak": 5,
    "status": "Healthy"
}

# --- HEALTH DATA STORAGE ---
health_events: List[dict] = []
health_logs: List[dict] = []

# Path to events.jsonl (generated by data_simulator.py)
EVENTS_FILE = os.path.join(os.path.dirname(os.path.dirname(__file__)), "events.jsonl")

def load_latest_events(limit: int = 50) -> List[dict]:
    """Load the latest events from events.jsonl"""
    events = []
    if os.path.exists(EVENTS_FILE):
        try:
            with open(EVENTS_FILE, 'r') as f:
                lines = f.readlines()
                # Get last N lines
                for line in lines[-limit:]:
                    try:
                        events.append(json.loads(line.strip()))
                    except json.JSONDecodeError:
                        continue
        except Exception as e:
            print(f"Error reading events file: {e}")
    return events

def get_current_health_state() -> dict:
    """Get the current health state from the latest event"""
    events = load_latest_events(1)
    if events:
        event = events[0]
        return {
            "glucose": extract_metric(event, "glucose", 5.5),
            "heart_rate": extract_metric(event, "heart_rate", 85),
            "mood": extract_metric(event, "mood", 0.7),
            "activity": extract_metric(event, "activity", 0.5),
            "spo2": extract_metric(event, "oxygen", 98),
            "asthma_risk": extract_metric(event, "asthma", 0.2),
            "health_score": event.get("health_score", 75),
            "safety_status": event.get("safety_status", "SAFE"),
            "last_event": event
        }
    return {
        "glucose": 5.5,
        "heart_rate": 85,
        "mood": 0.7,
        "activity": 0.5,
        "spo2": 98,
        "asthma_risk": 0.2,
        "health_score": 75,
        "safety_status": "SAFE",
        "last_event": None
    }

def extract_metric(event: dict, keyword: str, default: float) -> float:
    """Extract a metric value from an event based on event type"""
    event_type = event.get("event_type", "")
    if keyword in event_type.lower():
        return event.get("value", default)
    return default

@app.get("/")
def health_check():
    return {"status": "Leo is awake!", "stats": user_stats}

@app.get("/api/health/current")
def get_current_health():
    """Get current health metrics from simulator"""
    state = get_current_health_state()
    return {
        "metrics": {
            "glucose": {
                "value": state["glucose"],
                "unit": "mmol/L",
                "status": "normal" if 4.0 <= state["glucose"] <= 7.0 else "warning" if state["glucose"] < 4.0 else "elevated"
            },
            "heart_rate": {
                "value": state["heart_rate"],
                "unit": "bpm",
                "status": "normal" if 70 <= state["heart_rate"] <= 110 else "warning"
            },
            "mood": {
                "value": state["mood"],
                "unit": "score",
                "status": "good" if state["mood"] > 0.6 else "low" if state["mood"] < 0.4 else "neutral"
            },
            "activity": {
                "value": state["activity"],
                "unit": "score",
                "status": "active" if state["activity"] > 0.6 else "sedentary" if state["activity"] < 0.3 else "moderate"
            },
            "spo2": {
                "value": state["spo2"],
                "unit": "%",
                "status": "normal" if state["spo2"] >= 95 else "low"
            },
            "asthma_risk": {
                "value": state["asthma_risk"],
                "unit": "score",
                "status": "low" if state["asthma_risk"] < 0.4 else "moderate" if state["asthma_risk"] < 0.7 else "high"
            }
        },
        "health_score": state["health_score"],
        "safety_status": state["safety_status"],
        "timestamp": datetime.now().isoformat()
    }

@app.get("/api/health/events")
def get_health_events(limit: int = 20):
    """Get recent health events from simulator"""
    events = load_latest_events(limit)
    
    # Transform events for frontend
    formatted_events = []
    for event in events:
        formatted_events.append({
            "id": event.get("timestamp", ""),
            "type": event.get("event_type", "unknown"),
            "value": event.get("value", 0),
            "unit": event.get("unit", ""),
            "urgency": event.get("urgency", "low"),
            "safety_status": event.get("safety_status", "SAFE"),
            "health_score": event.get("health_score", 75),
            "anomaly_score": event.get("anomaly_score", 0),
            "trend": event.get("trend", "stable"),
            "reasoning": event.get("llm_reasoning", ""),
            "timestamp": event.get("timestamp", ""),
            "correlations": event.get("correlation_tags", []),
            "metadata": event.get("metadata", {})
        })
    
    return {
        "events": formatted_events,
        "total": len(formatted_events),
        "timestamp": datetime.now().isoformat()
    }

@app.get("/api/health/statistics")
def get_health_statistics():
    """Get health statistics summary"""
    events = load_latest_events(100)
    
    if not events:
        return {
            "total_events": 0,
            "danger_count": 0,
            "monitor_count": 0,
            "safe_count": 0,
            "avg_health_score": 75,
            "avg_glucose": 5.5,
            "avg_heart_rate": 85,
            "anomalies_detected": 0
        }
    
    # Calculate statistics
    danger_count = sum(1 for e in events if e.get("safety_status") == "DANGER")
    monitor_count = sum(1 for e in events if e.get("safety_status") == "MONITOR")
    safe_count = sum(1 for e in events if e.get("safety_status") == "SAFE")
    
    health_scores = [e.get("health_score", 75) for e in events if e.get("health_score")]
    avg_health = sum(health_scores) / len(health_scores) if health_scores else 75
    
    glucose_values = [e.get("value", 5.5) for e in events if "glucose" in e.get("event_type", "")]
    avg_glucose = sum(glucose_values) / len(glucose_values) if glucose_values else 5.5
    
    hr_values = [e.get("value", 85) for e in events if "heart" in e.get("event_type", "")]
    avg_hr = sum(hr_values) / len(hr_values) if hr_values else 85
    
    anomalies = sum(1 for e in events if e.get("anomaly_score", 0) > 0.7)
    
    return {
        "total_events": len(events),
        "danger_count": danger_count,
        "monitor_count": monitor_count,
        "safe_count": safe_count,
        "avg_health_score": round(avg_health, 1),
        "avg_glucose": round(avg_glucose, 2),
        "avg_heart_rate": round(avg_hr, 0),
        "anomalies_detected": anomalies,
        "timestamp": datetime.now().isoformat()
    }

@app.get("/api/health/alerts")
def get_health_alerts():
    """Get current health alerts that need attention"""
    events = load_latest_events(50)
    
    alerts = []
    for event in events:
        if event.get("safety_status") in ["DANGER", "MONITOR"]:
            alerts.append({
                "id": event.get("timestamp", ""),
                "type": event.get("event_type", "unknown"),
                "value": event.get("value", 0),
                "unit": event.get("unit", ""),
                "severity": "critical" if event.get("safety_status") == "DANGER" else "warning",
                "message": event.get("llm_reasoning", "Health event requires attention"),
                "timestamp": event.get("timestamp", ""),
                "health_score": event.get("health_score", 0),
                "urgency": event.get("urgency", "medium")
            })
    
    # Sort by timestamp (most recent first)
    alerts.sort(key=lambda x: x["timestamp"], reverse=True)
    
    return {
        "alerts": alerts[:10],  # Return top 10 alerts
        "total": len(alerts),
        "has_critical": any(a["severity"] == "critical" for a in alerts),
        "timestamp": datetime.now().isoformat()
    }

@app.post("/api/chat/stream")
async def chat_stream(user_msg: UserMessage):
    """
    The Main Interaction Loop:
    1. Analyze Intent (DeepSeek)
    2. Stream Response (Gemma)
    """
    print(f"ü¶Å User ({user_msg.age}y): {user_msg.message}")
    
    # 1. Logic / Safety Check
    intent = await analyze_intent(user_msg.message, user_msg.age)
    print(f"üß† Brain Analysis: {intent}")
    
    # 2. Empathy Stream
    return StreamingResponse(
        generate_leo_response(user_msg, intent), 
        media_type="text/event-stream"
    )

@app.post("/api/log/health")
def log_health(log: HealthLog):
    global user_stats
    
<<<<<<< Updated upstream
    # 1. Update Game Stats based on Health Score
    if log.health_score:
        user_stats["xp"] += int(log.health_score / 10) # 100 health = 10 XP
=======
    # Store the log
    health_logs.append({
        "user_id": log.user_id,
        "metric_type": log.metric_type,
        "value": log.value,
        "unit": log.unit,
        "timestamp": datetime.now().isoformat()
    })
    
    # Gamification Logic
    xp_gain = 10
    if 4.0 <= log.value <= 10.0: # Normal Range (Metric dependent)
        xp_gain = 25
        user_stats["status"] = "Super Strong"
    else:
        user_stats["status"] = "Recovering"

    user_stats["xp"] += xp_gain
>>>>>>> Stashed changes
    
    # 2. Update Status Text based on Event Type
    if log.safety_status == "DANGER":
        user_stats["status"] = "Needs Help! üö®"
    elif log.safety_status == "MONITOR":
        user_stats["status"] = "Check Engine ‚ö†Ô∏è"
    else:
        user_stats["status"] = "Super Strong ü¶Å"

    # 3. Dynamic Avatar State (For the UI to react)
    # We send this back so the frontend knows if Leo should look sad/happy
    avatar_mood = "happy"
    if log.event_type == "glucose_drop" or log.safety_status == "DANGER":
        avatar_mood = "worried"
    
    # Check for level up
    if user_stats["xp"] >= user_stats["level"] * 100:
        user_stats["level"] += 1
        user_stats["xp"] = 0
    
    return {
        "event": "LOGGED", 
        "xp_gained": int(log.health_score / 10) if log.health_score else 5,
        "avatar_mood": avatar_mood
    }

@app.get("/api/logs/health")
def get_health_logs(limit: int = 50):
    """Get stored health logs"""
    return {
        "logs": health_logs[-limit:],
        "total": len(health_logs)
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
