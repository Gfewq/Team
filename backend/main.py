from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse
from backend.models import UserMessage, HealthLog
from backend.services.brain_service import analyze_intent, generate_leo_response
from backend.services.notification_service import set_parent_contact, notify_parent_critical
import asyncio
import json
<<<<<<< Updated upstream
import os
from datetime import datetime
from typing import List, Optional
from pydantic import BaseModel
=======
>>>>>>> Stashed changes

app = FastAPI(title="Leo Health API", version="2.0")

# Allow React Frontend (localhost:3000)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Lock this down for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- GAMIFICATION STATE (Simple In-Memory for Hackathon) ---
user_stats = {
    "xp": 120,
    "level": 3,
    "streak": 5,
    "status": "Healthy"
}
last_notified_status = None  # Track to avoid duplicate notifications

# --- HEALTH DATA STORAGE ---
health_events: List[dict] = []
health_logs: List[dict] = []

# Path to events.jsonl (generated by data_simulator.py)
EVENTS_FILE = os.path.join(os.path.dirname(os.path.dirname(__file__)), "events.jsonl")

def load_latest_events(limit: int = 50) -> List[dict]:
    """Load the latest events from events.jsonl"""
    events = []
    if os.path.exists(EVENTS_FILE):
        try:
            with open(EVENTS_FILE, 'r') as f:
                lines = f.readlines()
                # Get last N lines
                for line in lines[-limit:]:
                    try:
                        events.append(json.loads(line.strip()))
                    except json.JSONDecodeError:
                        continue
        except Exception as e:
            print(f"Error reading events file: {e}")
    return events

def get_current_health_state() -> dict:
    """Get the current health state from the latest event"""
    events = load_latest_events(1)
    if events:
        event = events[0]
        return {
            "glucose": extract_metric(event, "glucose", 5.5),
            "heart_rate": extract_metric(event, "heart_rate", 85),
            "mood": extract_metric(event, "mood", 0.7),
            "activity": extract_metric(event, "activity", 0.5),
            "spo2": extract_metric(event, "oxygen", 98),
            "asthma_risk": extract_metric(event, "asthma", 0.2),
            "health_score": event.get("health_score", 75),
            "safety_status": event.get("safety_status", "SAFE"),
            "last_event": event
        }
    return {
        "glucose": 5.5,
        "heart_rate": 85,
        "mood": 0.7,
        "activity": 0.5,
        "spo2": 98,
        "asthma_risk": 0.2,
        "health_score": 75,
        "safety_status": "SAFE",
        "last_event": None
    }

def extract_metric(event: dict, keyword: str, default: float) -> float:
    """Extract a metric value from an event based on event type"""
    event_type = event.get("event_type", "")
    if keyword in event_type.lower():
        return event.get("value", default)
    return default

@app.get("/")
def health_check():
    return {"status": "Leo is awake!", "stats": user_stats}

<<<<<<< Updated upstream
@app.get("/api/health/current")
def get_current_health():
    """Get current health metrics from simulator"""
    state = get_current_health_state()
    return {
        "metrics": {
            "glucose": {
                "value": state["glucose"],
                "unit": "mmol/L",
                "status": "normal" if 4.0 <= state["glucose"] <= 7.0 else "warning" if state["glucose"] < 4.0 else "elevated"
            },
            "heart_rate": {
                "value": state["heart_rate"],
                "unit": "bpm",
                "status": "normal" if 70 <= state["heart_rate"] <= 110 else "warning"
            },
            "mood": {
                "value": state["mood"],
                "unit": "score",
                "status": "good" if state["mood"] > 0.6 else "low" if state["mood"] < 0.4 else "neutral"
            },
            "activity": {
                "value": state["activity"],
                "unit": "score",
                "status": "active" if state["activity"] > 0.6 else "sedentary" if state["activity"] < 0.3 else "moderate"
            },
            "spo2": {
                "value": state["spo2"],
                "unit": "%",
                "status": "normal" if state["spo2"] >= 95 else "low"
            },
            "asthma_risk": {
                "value": state["asthma_risk"],
                "unit": "score",
                "status": "low" if state["asthma_risk"] < 0.4 else "moderate" if state["asthma_risk"] < 0.7 else "high"
            }
        },
        "health_score": state["health_score"],
        "safety_status": state["safety_status"],
        "timestamp": datetime.now().isoformat()
    }

@app.get("/api/health/events")
def get_health_events(limit: int = 20):
    """Get recent health events from simulator"""
    events = load_latest_events(limit)
    
    # Transform events for frontend
    formatted_events = []
    for event in events:
        formatted_events.append({
            "id": event.get("timestamp", ""),
            "type": event.get("event_type", "unknown"),
            "value": event.get("value", 0),
            "unit": event.get("unit", ""),
            "urgency": event.get("urgency", "low"),
            "safety_status": event.get("safety_status", "SAFE"),
            "health_score": event.get("health_score", 75),
            "anomaly_score": event.get("anomaly_score", 0),
            "trend": event.get("trend", "stable"),
            "reasoning": event.get("llm_reasoning", ""),
            "timestamp": event.get("timestamp", ""),
            "correlations": event.get("correlation_tags", []),
            "metadata": event.get("metadata", {})
        })
    
    return {
        "events": formatted_events,
        "total": len(formatted_events),
        "timestamp": datetime.now().isoformat()
    }

@app.get("/api/health/statistics")
def get_health_statistics():
    """Get health statistics summary"""
    events = load_latest_events(100)
    
    if not events:
        return {
            "total_events": 0,
            "danger_count": 0,
            "monitor_count": 0,
            "safe_count": 0,
            "avg_health_score": 75,
            "avg_glucose": 5.5,
            "avg_heart_rate": 85,
            "anomalies_detected": 0
        }
    
    # Calculate statistics
    danger_count = sum(1 for e in events if e.get("safety_status") == "DANGER")
    monitor_count = sum(1 for e in events if e.get("safety_status") == "MONITOR")
    safe_count = sum(1 for e in events if e.get("safety_status") == "SAFE")
    
    health_scores = [e.get("health_score", 75) for e in events if e.get("health_score")]
    avg_health = sum(health_scores) / len(health_scores) if health_scores else 75
    
    glucose_values = [e.get("value", 5.5) for e in events if "glucose" in e.get("event_type", "")]
    avg_glucose = sum(glucose_values) / len(glucose_values) if glucose_values else 5.5
    
    hr_values = [e.get("value", 85) for e in events if "heart" in e.get("event_type", "")]
    avg_hr = sum(hr_values) / len(hr_values) if hr_values else 85
    
    anomalies = sum(1 for e in events if e.get("anomaly_score", 0) > 0.7)
    
    return {
        "total_events": len(events),
        "danger_count": danger_count,
        "monitor_count": monitor_count,
        "safe_count": safe_count,
        "avg_health_score": round(avg_health, 1),
        "avg_glucose": round(avg_glucose, 2),
        "avg_heart_rate": round(avg_hr, 0),
        "anomalies_detected": anomalies,
        "timestamp": datetime.now().isoformat()
    }

@app.get("/api/health/alerts")
def get_health_alerts():
    """Get current health alerts that need attention"""
    events = load_latest_events(50)
    
    alerts = []
    for event in events:
        if event.get("safety_status") in ["DANGER", "MONITOR"]:
            alerts.append({
                "id": event.get("timestamp", ""),
                "type": event.get("event_type", "unknown"),
                "value": event.get("value", 0),
                "unit": event.get("unit", ""),
                "severity": "critical" if event.get("safety_status") == "DANGER" else "warning",
                "message": event.get("llm_reasoning", "Health event requires attention"),
                "timestamp": event.get("timestamp", ""),
                "health_score": event.get("health_score", 0),
                "urgency": event.get("urgency", "medium")
            })
    
    # Sort by timestamp (most recent first)
    alerts.sort(key=lambda x: x["timestamp"], reverse=True)
    
    return {
        "alerts": alerts[:10],  # Return top 10 alerts
        "total": len(alerts),
        "has_critical": any(a["severity"] == "critical" for a in alerts),
        "timestamp": datetime.now().isoformat()
    }
=======
def _sse_wrap(gen):
    """Wrap raw text stream in SSE format (data: ...\\n) so frontend can parse it."""
    async def wrapped():
        async for chunk in gen:
            yield f"data: {json.dumps(chunk)}\n"
        yield "data: [DONE]\n"
    return wrapped()
>>>>>>> Stashed changes

@app.post("/api/chat/stream")
async def chat_stream(user_msg: UserMessage):
    """
    The Main Interaction Loop:
    1. Analyze Intent (DeepSeek)
    2. Stream Response (Gemma)
    """
    print(f"ðŸ¦ User ({user_msg.age}y): {user_msg.message}")
    
    # 1. Logic / Safety Check
    intent = await analyze_intent(user_msg.message, user_msg.age)
    print(f"ðŸ§  Brain Analysis: {intent}")
    
    # 2. Empathy Stream (wrapped in SSE format for frontend)
    return StreamingResponse(
        _sse_wrap(generate_leo_response(user_msg, intent)), 
        media_type="text/event-stream"
    )

def check_metric_critical(metric_type: str, value: float) -> tuple[bool, str]:
    """
    Check if a metric is critical and return (is_critical, status_message)
    """
    metric_type_lower = metric_type.lower()
    
    # Glucose thresholds
    if "glucose" in metric_type_lower:
        if value < 4.0:
            return True, "Help Needed - Low Glucose"
        elif value > 10.0:
            return True, "Check Required - High Glucose"
        else:
            return False, "Super Strong"
    
    # Blood Pressure thresholds (systolic/diastolic)
    elif "bp" in metric_type_lower or "blood_pressure" in metric_type_lower or "pressure" in metric_type_lower:
        # Assuming format like "120/80" or separate systolic/diastolic
        # For simplicity, if value is systolic (higher number)
        if value < 90:  # Low BP
            return True, "Help Needed - Low Blood Pressure"
        elif value > 140:  # High BP
            return True, "Check Required - High Blood Pressure"
        else:
            return False, "Super Strong"
    
    # Heart Rate thresholds
    elif "heart" in metric_type_lower or "pulse" in metric_type_lower or "hr" in metric_type_lower:
        if value < 60:  # Low heart rate
            return True, "Help Needed - Low Heart Rate"
        elif value > 100:  # High heart rate (for children, adjust as needed)
            return True, "Check Required - High Heart Rate"
        else:
            return False, "Super Strong"
    
    # Default: check if value is very low or very high
    else:
        if value < 1.0 or value > 200:  # Generic critical thresholds
            return True, f"Check Required - {metric_type} Critical"
        else:
            return False, "Super Strong"

@app.post("/api/log/health")
def log_health(log: HealthLog):
<<<<<<< Updated upstream
    global user_stats
    
<<<<<<< Updated upstream
    # 1. Update Game Stats based on Health Score
    if log.health_score:
        user_stats["xp"] += int(log.health_score / 10) # 100 health = 10 XP
=======
    # Store the log
    health_logs.append({
        "user_id": log.user_id,
        "metric_type": log.metric_type,
        "value": log.value,
        "unit": log.unit,
        "timestamp": datetime.now().isoformat()
    })
    
    # Gamification Logic
=======
    """
    Gamification Endpoint:
    Logs health data and rewards XP.
    Handles multiple metrics: glucose, BP, heart rate, etc.
    """
    global user_stats, last_notified_status
    
    # Check if this metric is critical
    is_critical, status_msg = check_metric_critical(log.metric_type, log.value)
    
    print(f"ðŸ“Š Received {log.metric_type}: {log.value} {log.unit}")
    
>>>>>>> Stashed changes
    xp_gain = 10
    
    if is_critical:
        user_stats["status"] = status_msg
        print(f"ðŸš¨ CRITICAL: {status_msg} ({log.metric_type}: {log.value})")
        # Automatically notify parent (only once per status change)
        if last_notified_status != status_msg:
            notify_parent_critical(log.value, status_msg, log.metric_type)
            last_notified_status = status_msg
    else:
        # Normal range - check if we should update status
        if "Super Strong" in status_msg:
            xp_gain = 25
            # Only update to "Super Strong" if not already critical
            if not any(word in user_stats["status"].lower() for word in ["help", "check", "critical"]):
                user_stats["status"] = status_msg
            print(f"âœ… Normal {log.metric_type} range")
            last_notified_status = None  # Reset notification flag when back to normal

    user_stats["xp"] += xp_gain
>>>>>>> Stashed changes
    
    # 2. Update Status Text based on Event Type
    if log.safety_status == "DANGER":
        user_stats["status"] = "Needs Help! ðŸš¨"
    elif log.safety_status == "MONITOR":
        user_stats["status"] = "Check Engine âš ï¸"
    else:
        user_stats["status"] = "Super Strong ðŸ¦"

    # 3. Dynamic Avatar State (For the UI to react)
    # We send this back so the frontend knows if Leo should look sad/happy
    avatar_mood = "happy"
    if log.event_type == "glucose_drop" or log.safety_status == "DANGER":
        avatar_mood = "worried"
    
    # Check for level up
    if user_stats["xp"] >= user_stats["level"] * 100:
        user_stats["level"] += 1
        user_stats["xp"] = 0
    
    return {
        "event": "LOGGED", 
        "xp_gained": int(log.health_score / 10) if log.health_score else 5,
        "avatar_mood": avatar_mood
    }

@app.get("/api/logs/health")
def get_health_logs(limit: int = 50):
    """Get stored health logs"""
    return {
        "logs": health_logs[-limit:],
        "total": len(health_logs)
    }

@app.post("/api/test/glucose")
def test_glucose(value: float):
    """
    TEST ENDPOINT: Manually set glucose value for testing
    Usage: POST /api/test/glucose?value=3.5
    """
    test_log = HealthLog(
        user_id="test_user",
        metric_type="glucose",
        value=value,
        unit="mmol/L"
    )
    return log_health(test_log)

@app.post("/api/settings/parent")
def save_parent_contact(phone: str = "", email: str = ""):
    """
    Save parent contact information
    """
    result = set_parent_contact(phone, email)
    return {"message": "Parent contact saved", "contact": result}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
